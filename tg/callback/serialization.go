package callback

import (
	"fmt"
	"reflect"
	"strconv"
	"strings"

	log "github.com/sirupsen/logrus"
)

type Key int

// Information Separator One symbol
const serializationSeparator = "\u001f"
const nilKey Key = 0

type callback struct {
	key      Key
	dataType reflect.Type
}

var byKey = map[Key]callback{}
var byTypeName = map[string]callback{}

func addCallback(data interface{}) {
	t := reflect.TypeOf(data)

	if _, exists := byTypeName[t.Name()]; exists {
		log.WithFields(log.Fields{
			"zero_value": data,
			"type_name":  t.Name(),
		}).Fatal("callback with that NameTest is already added")
	}

	clb := callback{
		key:      Key(len(byTypeName) + 1),
		dataType: t,
	}

	byTypeName[clb.dataType.Name()] = clb
	byKey[clb.key] = clb
}

func keyToString(key Key) string {
	return strconv.Itoa(int(key))
}

// Marshal marshals a callback to the Telegram callback_data field.
func Marshal(obj interface{}) string {
	return strings.Join(marshalRecursively(obj), serializationSeparator)
}

// marshalRecursively marshals an obj to the array of strings recursively
func marshalRecursively(obj interface{}) []string {
	var result []string

	if obj == nil {
		return append(result, keyToString(nilKey))
	}

	// Try to find among callbacks
	clb, exists := byTypeName[reflect.TypeOf(obj).Name()]
	if exists {
		result = append(result, keyToString(clb.key))
	}

	value := reflect.ValueOf(obj)

	switch value.Kind() {
	case reflect.Struct:
		numField := value.NumField()
		for i := 0; i < numField; i++ {
			result = append(result, marshalRecursively(value.Field(i).Interface())...)
		}

	case reflect.Slice:
		sliceLen := value.Len()
		result = append(result, keyToString(Key(sliceLen)))
		for i := 0; i < sliceLen; i++ {
			result = append(result, marshalRecursively(value.Index(i).Interface())...)
		}

	default:
		result = append(result, fmt.Sprintf("%v", obj))
	}

	return result
}

// Unmarshal unmarshals the callback from a Telegram callback_data field.
func Unmarshal(callbackData string) interface{} {
	var clb interface{}
	decoded := strings.Split(callbackData, serializationSeparator)

	notUsed := unmarshalRecursively(decoded, reflect.ValueOf(&clb))
	if len(notUsed) != 0 {
		log.WithFields(log.Fields{
			"callback_data": callbackData,
			"not_used":      notUsed,
		}).Error("there are some extra information in the callback_data")
	}

	return clb
}

// unmarshalRecursively reverses marshalRecursively's response.
// It recursively unmarshals a callback from the array of strings, generated by marshalRecursively.
func unmarshalRecursively(data []string, value reflect.Value) []string {
	logger := log.WithFields(log.Fields{
		"value": value,
		"data":  data,
	})

	// At first, check kinds when the data can be empty
	switch value.Kind() {
	case reflect.Ptr:
		return unmarshalRecursively(data, value.Elem())

	case reflect.Struct: // Parse the fields separately
		numField := value.NumField()
		for i := 0; i < numField; i++ {
			data = unmarshalRecursively(data, value.Field(i))
		}
		return data
	}

	if len(data) == 0 {
		logger.Error("data is empty, but not all objects were read")
		return data
	}

	switch value.Kind() {
	case reflect.Slice: // Parse the items separately
		newLen, err := strconv.Atoi(data[0])
		if err != nil {
			logger.WithError(err).Error("failed to read the array length")
			return data
		}
		data = data[1:]

		elem := value.Type().Elem()
		value.Set(reflect.MakeSlice(reflect.SliceOf(elem), newLen, newLen))

		for i := 0; i < newLen; i++ {
			data = unmarshalRecursively(data, value.Index(i))
		}

	case reflect.Interface: // Parse as a callback
		k, err := strconv.Atoi(data[0])
		if err != nil {
			logger.WithError(err).Error("failed to read the callback key")
			return data
		}

		data = data[1:]
		key := Key(k)

		if key == nilKey {
			value.Set(reflect.Zero(value.Type()))
			return data
		}

		clb, exists := byKey[key]
		if !exists {
			logger.WithField("key", key).Error("callback with the key doesn't exist")
			return data
		}

		tmp := reflect.New(clb.dataType).Elem()
		data = unmarshalRecursively(data, tmp)
		value.Set(tmp)

	case reflect.String: // Strings are not correctly parsed with the %v parser :(
		value.SetString(data[0])
		data = data[1:]

	default:
		_, err := fmt.Sscanf(data[0], "%v", value.Addr().Interface())
		if err != nil {
			logger.WithField("type", value.Type().Name()).WithError(err).Error("failed to scan the value")
		}

		data = data[1:]
	}

	return data
}
